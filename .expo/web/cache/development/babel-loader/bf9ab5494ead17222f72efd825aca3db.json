{"ast":null,"code":"'use strict';\n\nimport invariant from 'fbjs/lib/invariant';\n\nfunction elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {\n  var out = [];\n  var outLength = 0;\n\n  for (var ii = 0; ii < itemCount; ii++) {\n    var frame = getFrameMetrics(ii);\n    var trailingOffset = frame.offset + frame.length;\n\n    for (var kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        outLength++;\n\n        if (kk === offsets.length - 1) {\n          invariant(outLength === offsets.length, 'bad offsets input, should be in increasing order: %s', JSON.stringify(offsets));\n          return out;\n        }\n      }\n    }\n  }\n\n  return out;\n}\n\nfunction newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\n\nfunction computeWindowedRenderLimits(props, prev, getFrameMetricsApprox, scrollMetrics) {\n  var data = props.data,\n      getItemCount = props.getItemCount,\n      maxToRenderPerBatch = props.maxToRenderPerBatch,\n      windowSize = props.windowSize;\n  var itemCount = getItemCount(data);\n\n  if (itemCount === 0) {\n    return prev;\n  }\n\n  var offset = scrollMetrics.offset,\n      velocity = scrollMetrics.velocity,\n      visibleLength = scrollMetrics.visibleLength;\n  var visibleBegin = Math.max(0, offset);\n  var visibleEnd = visibleBegin + visibleLength;\n  var overscanLength = (windowSize - 1) * visibleLength;\n  var leadFactor = 0.5;\n  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;\n\n  if (lastItemOffset < overscanBegin) {\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1\n    };\n  }\n\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props.getItemCount(props.data), getFrameMetricsApprox),\n      overscanFirst = _elementsThatOverlapO[0],\n      first = _elementsThatOverlapO[1],\n      last = _elementsThatOverlapO[2],\n      overscanLast = _elementsThatOverlapO[3];\n\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  var visible = {\n    first: first,\n    last: last\n  };\n  var newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      break;\n    }\n\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\n    var firstWillAddMore = first <= prev.first || first > prev.last;\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    var lastWillAddMore = last >= prev.last || last < prev.first;\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      break;\n    }\n\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n\n      first--;\n    }\n\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n\n      last++;\n    }\n  }\n\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error('Bad window calculation ' + JSON.stringify({\n      first: first,\n      last: last,\n      itemCount: itemCount,\n      overscanFirst: overscanFirst,\n      overscanLast: overscanLast,\n      visible: visible\n    }));\n  }\n\n  return {\n    first: first,\n    last: last\n  };\n}\n\nvar VirtualizeUtils = {\n  computeWindowedRenderLimits: computeWindowedRenderLimits,\n  elementsThatOverlapOffsets: elementsThatOverlapOffsets,\n  newRangeCount: newRangeCount\n};\nexport { computeWindowedRenderLimits, elementsThatOverlapOffsets, newRangeCount };\nexport default VirtualizeUtils;","map":{"version":3,"sources":["/Users/garethcozens/Documents/repo/cloudratha/react-native-web-nx-demo/node_modules/react-native-web/dist/vendor/react-native/VirtualizeUtils/index.js"],"names":["out","outLength","ii","frame","getFrameMetrics","trailingOffset","kk","offsets","invariant","JSON","next","Math","prev","data","props","getItemCount","maxToRenderPerBatch","windowSize","itemCount","offset","scrollMetrics","velocity","visibleLength","visibleBegin","visibleEnd","overscanLength","leadFactor","fillPreference","overscanBegin","overscanEnd","lastItemOffset","getFrameMetricsApprox","first","last","_elementsThatOverlapO","elementsThatOverlapOffsets","overscanFirst","overscanLast","visible","newCellCount","newRangeCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","VirtualizeUtils","computeWindowedRenderLimits"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nimport invariant from 'fbjs/lib/invariant';\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\n\nfunction elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {\n  var out = [];\n  var outLength = 0;\n\n  for (var ii = 0; ii < itemCount; ii++) {\n    var frame = getFrameMetrics(ii);\n    var trailingOffset = frame.offset + frame.length;\n\n    for (var kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        outLength++;\n\n        if (kk === offsets.length - 1) {\n          invariant(outLength === offsets.length, 'bad offsets input, should be in increasing order: %s', JSON.stringify(offsets));\n          return out;\n        }\n      }\n    }\n  }\n\n  return out;\n}\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\n\n\nfunction newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\n\n\nfunction computeWindowedRenderLimits(props, prev, getFrameMetricsApprox, scrollMetrics) {\n  var data = props.data,\n      getItemCount = props.getItemCount,\n      maxToRenderPerBatch = props.maxToRenderPerBatch,\n      windowSize = props.windowSize;\n  var itemCount = getItemCount(data);\n\n  if (itemCount === 0) {\n    return prev;\n  }\n\n  var offset = scrollMetrics.offset,\n      velocity = scrollMetrics.velocity,\n      visibleLength = scrollMetrics.visibleLength; // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n\n  var visibleBegin = Math.max(0, offset);\n  var visibleEnd = visibleBegin + visibleLength;\n  var overscanLength = (windowSize - 1) * visibleLength; // Considering velocity seems to introduce more churn than it's worth.\n\n  var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;\n\n  if (lastItemOffset < overscanBegin) {\n    // Entire list is before our overscan window\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1\n    };\n  } // Find the indices that correspond to the items at the render boundaries we're targeting.\n\n\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props.getItemCount(props.data), getFrameMetricsApprox),\n      overscanFirst = _elementsThatOverlapO[0],\n      first = _elementsThatOverlapO[1],\n      last = _elementsThatOverlapO[2],\n      overscanLast = _elementsThatOverlapO[3];\n\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  var visible = {\n    first: first,\n    last: last\n  }; // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n\n  var newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\n    var firstWillAddMore = first <= prev.first || first > prev.last;\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    var lastWillAddMore = last >= prev.last || last < prev.first;\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n\n      first--;\n    }\n\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n\n      last++;\n    }\n  }\n\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error('Bad window calculation ' + JSON.stringify({\n      first: first,\n      last: last,\n      itemCount: itemCount,\n      overscanFirst: overscanFirst,\n      overscanLast: overscanLast,\n      visible: visible\n    }));\n  }\n\n  return {\n    first: first,\n    last: last\n  };\n}\n\nvar VirtualizeUtils = {\n  computeWindowedRenderLimits: computeWindowedRenderLimits,\n  elementsThatOverlapOffsets: elementsThatOverlapOffsets,\n  newRangeCount: newRangeCount\n};\nexport { computeWindowedRenderLimits, elementsThatOverlapOffsets, newRangeCount };\nexport default VirtualizeUtils;"]},"metadata":{},"sourceType":"module"}